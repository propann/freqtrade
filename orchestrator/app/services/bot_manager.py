from __future__ import annotations

import uuid
import json
from pathlib import Path
from typing import List

from fastapi import HTTPException

from ..models import (
    ActionResponse,
    AuditEntry,
    BotConfig,
    BotInstance,
    BotRiskLimits,
    BotStatus,
    CreateBotRequest,
    SubscriptionStatus,
    Tenant,
    TenantPlan,
    TenantQuotas,
)
from ..utils.guards import ensure_active_subscription
from ..utils.secrets import vault
from .state import StateStore
from .quota_manager import QuotaManager


class BotManager:
    """Coordinator responsible for tenant isolation and lifecycle transitions."""

    PLAN_QUOTAS: dict[TenantPlan, TenantQuotas] = {
        TenantPlan.basic: TenantQuotas(
            max_bots=1,
            cpu_limit=0.5,
            mem_limit="512m",
            allow_hyperopt=False,
            allow_backtest=False,
        ),
        TenantPlan.pro: TenantQuotas(
            max_bots=3,
            cpu_limit=1.0,
            mem_limit="1024m",
            allow_hyperopt=True,
            allow_backtest=True,
        ),
        TenantPlan.whale: TenantQuotas(
            max_bots=10,
            cpu_limit=2.0,
            mem_limit="4096m",
            allow_hyperopt=True,
            allow_backtest=True,
        ),
    }

    def __init__(self, base_dir: Path):
        self.base_dir = base_dir
        self.state = StateStore(base_dir / "state")
        self.clients_dir = base_dir / ".." / "clients"
        self.clients_dir.mkdir(parents=True, exist_ok=True)
        self.quota_manager = QuotaManager(self.state)

    def create_tenant(
        self,
        tenant_id: str,
        email: str,
        subscription_id: str | None = None,
        subscription_status: Tenant.__fields__["subscription_status"].type_ | None = None,
        plan: TenantPlan | None = None,
    ) -> Tenant:
        tenant = Tenant(
            tenant_id=tenant_id,
            email=email,
            subscription_id=subscription_id,
            subscription_status=subscription_status or Tenant.__fields__["subscription_status"].type_.suspended,
            plan=plan or TenantPlan.basic,
        )
        return self.state.upsert_tenant(tenant)

    def _tenant_dir(self, tenant_id: str) -> Path:
        tdir = self.clients_dir / tenant_id
        tdir.mkdir(parents=True, exist_ok=True)
        (tdir / "data").mkdir(exist_ok=True)
        return tdir

    def _build_config(self, tenant_id: str, bot_id: str, payload: CreateBotRequest) -> BotConfig:
        tenant_dir = self._tenant_dir(tenant_id)
        config_dir = tenant_dir / "configs"
        state_dir = tenant_dir / "state"
        logs_dir = tenant_dir / "logs"
        for folder in (config_dir, state_dir, logs_dir):
            folder.mkdir(exist_ok=True)
        config_path = config_dir / f"{bot_id}-{payload.template}.json"
        config_path.write_text(
            """
{
  "comment": "Template generated by orchestrator; ensure secrets injected at runtime via AWS.",
  "dry_run": true,
  "strategy": "%s",
  "stake_amount": %s,
  "max_open_trades": %s
}
"""
            % (payload.strategy, payload.risk.stake_amount, payload.risk.max_concurrent_pairs)
        )
        return BotConfig(
            bot_id=bot_id,
            tenant_id=tenant_id,
            strategy=payload.strategy,
            template=payload.template,
            config_path=str(config_path),
            network=f"fta-client-{tenant_id}",
            state_path=str(state_dir),
            risk=payload.risk,
        )

    def create_bot(self, tenant_id: str, payload: CreateBotRequest, performed_by: str) -> ActionResponse:
        bot_id = str(uuid.uuid4())
        config = self._build_config(tenant_id, bot_id, payload)
        instance = BotInstance(bot_id=bot_id, tenant_id=tenant_id, config=config, status=BotStatus.created)
        self.state.save_bot(instance)
        audit = self.state.add_audit(
            AuditEntry(
                tenant_id=tenant_id,
                bot_id=bot_id,
                action="create",
                performed_by=performed_by,
                metadata={"template": payload.template, "strategy": payload.strategy},
            )
        )
        return ActionResponse(bot_id=bot_id, status=instance.status, message="Bot created", audit_ref=str(audit.ts))

    def _transition(
        self,
        bot_id: str,
        status: BotStatus,
        actor: str,
        message: str,
        metadata: dict[str, str] | None = None,
    ) -> ActionResponse:
        bot = self.state.get_bot(bot_id)
        if not bot:
            raise HTTPException(status_code=404, detail="Bot not found")
        updated = self.state.set_bot_status(bot_id, status)
        audit = self.state.add_audit(
            AuditEntry(
                tenant_id=bot.tenant_id,
                bot_id=bot.bot_id,
                action=status.value,
                performed_by=actor,
                metadata=metadata or {},
            )
        )
        return ActionResponse(bot_id=bot_id, status=updated.status, message=message, audit_ref=str(audit.ts))

    def get_tenant_quotas(self, tenant_id: str) -> TenantQuotas:
        tenants = {t.tenant_id: t for t in self.state.list_tenants()}
        tenant = tenants.get(tenant_id)
        if not tenant:
            raise HTTPException(status_code=404, detail="Tenant not found")
        return self.PLAN_QUOTAS.get(tenant.plan, self.PLAN_QUOTAS[TenantPlan.basic])

    def _enforce_quota_for_bot(self, bot_id: str) -> tuple[BotInstance, TenantQuotas]:
        bot = self.state.get_bot(bot_id)
        if not bot:
            raise HTTPException(status_code=404, detail="Bot not found")
        self.enforce_subscription(bot.tenant_id)
        if bot.status != BotStatus.running:
            quotas = self.get_tenant_quotas(bot.tenant_id)
            self.quota_manager.validate_spawn_request(bot.tenant_id, quotas)
            return bot, quotas
        return bot, self.get_tenant_quotas(bot.tenant_id)

    def start_bot(self, bot_id: str, actor: str) -> ActionResponse:
        bot, quotas = self._enforce_quota_for_bot(bot_id)
        self.prepare_bot_config(bot_id)
        resource_limits = self.quota_manager.get_docker_resource_config(quotas)
        return self._transition(
            bot_id,
            BotStatus.running,
            actor,
            "Bot started",
            metadata={"resource_limits": json.dumps(resource_limits)},
        )

    def pause_bot(self, bot_id: str, actor: str) -> ActionResponse:
        return self._transition(bot_id, BotStatus.paused, actor, "Bot paused")

    def restart_bot(self, bot_id: str, actor: str) -> ActionResponse:
        bot = self.state.get_bot(bot_id)
        if not bot:
            raise HTTPException(status_code=404, detail="Bot not found")
        self.enforce_subscription(bot.tenant_id)
        return self._transition(bot_id, BotStatus.running, actor, "Bot restarted")

    def status(self, bot_id: str) -> BotInstance:
        bot = self.state.get_bot(bot_id)
        if not bot:
            raise HTTPException(status_code=404, detail="Bot not found")
        return bot

    def prepare_bot_config(self, bot_id: str) -> dict:
        bot = self.state.get_bot(bot_id)
        if not bot:
            raise HTTPException(status_code=404, detail="Bot not found")
        config_path = Path(bot.config.config_path)
        if not config_path.exists():
            raise HTTPException(status_code=404, detail="Config template not found")
        base_template = json.loads(config_path.read_text())
        keys = vault.get_exchange_keys(bot.tenant_id)
        if not keys:
            raise HTTPException(
                status_code=500,
                detail=f"Impossible de démarrer le bot : Clés manquantes pour le tenant {bot.tenant_id}",
            )
        exchange_config = base_template.setdefault("exchange", {})
        exchange_config["key"] = keys["api_key"]
        exchange_config["secret"] = keys["api_secret"]
        return base_template

    def logs(self, bot_id: str) -> List[str]:
        bot = self.state.get_bot(bot_id)
        if not bot:
            raise HTTPException(status_code=404, detail="Bot not found")
        if bot.logs_path and Path(bot.logs_path).exists():
            return Path(bot.logs_path).read_text().splitlines()[-200:]
        return ["No logs captured yet"]

    def audit(self, tenant_id: str, bot_id: str | None = None) -> List[AuditEntry]:
        return self.state.list_audit(tenant_id=tenant_id, bot_id=bot_id)

    def enforce_subscription(self, tenant_id: str) -> None:
        tenants = {t.tenant_id: t for t in self.state.list_tenants()}
        tenant = tenants.get(tenant_id)
        if not tenant:
            raise HTTPException(status_code=404, detail="Tenant not found")
        ensure_active_subscription(tenant)

    def seed_demo(self) -> None:
        """Preload a demo tenant for local development."""
        tenant = Tenant(
            tenant_id="demo",
            email="demo@example.com",
            subscription_status=Tenant.__fields__["subscription_status"].type_.active,
        )
        self.state.upsert_tenant(tenant)
